#Node.js vs Python. На чем лучше писать ваш следующий проект?
Значительная часть серверных приложений сейчас пишется на Node.js и Python. С помощью каждой из платформ можно с лекостью разрабатывать и поддерживать веб-приложения любой сложности.
Но что же выбрать для вашего следующего проекта? Для этого нужно ознакомится с плюсами и минусами этих решений, для каких типов приложения какая платформа больше подходит.

##Вступление

В отличие от Python, который явлется вполне созревшим скриптовиым языком, Node.js это среда выполнения Javascript разработаная для использывания JS кода на сервере. Node.js одно из немногих серверных решений которое использует событиюную модель и авсинхронный ввод/вывод, которая позволяет создавать маштабируэмие приложения.
С другой стороны, Python это скриптовый,высокоуровневый и интерпретированый язык програмирования с акцентом на читабельность кода и продкутивность. Python был создан разработчиком Guido Van Rossum в 1991, поддержывает несколько парадигим, что делает его незаменимим для многих бизнес решений. Также сильниымы сторонами Python явлеются поддержка обьектно-ориентированного програмирования и мощная стандартная библиотека.

##Плюсы Node.js
**1) Быстрое серверное решение**
Не смотря на то что Node.js выполнется в одном потоке, он имееи событийно-ориентируваную архитектуру и не блокирующий ввод/ввывод, которий максимально использует ресурсы одного ядра. Событийно-ориентируваная архитектура и возможность горизонтального маштабирования позволяет ввыдержевать больше конкуретных запросов чем решение которые базируются на потоках.
**2) Один язык на бек-енде и фронт-енде**
До появление Node.js веб-програмистам приходилось работать с несколькими языками програмирование, например PHP и JS, часто это приводило к дублирувание кода на клиенте и на сервере. Но Node.js все иначе можно использовать совместную кодовую базу. Более того теперь использование одного языка позволяет сократить команду разработчиков.
**3)Маштабируемое решение**
Не смотря на то что Node.js однопоточный, его стандартная библиотека предоставлеет модули для маштабирования. Кластеры и worker's Node.js это абстракции которые позволяют создавать несколько отдельных Node.js процесов в зависимости от нагрузки на вашего приложения. Вы ограничени только количеством ядер на вашем сервере, по этому Node подходит для больши х ентрепрайзних решений.

##Недостаки Node.js

**1)Малая ефективность в операциях интесивно использущих CPU**

Событийно-ориентированая архитектура Node.js имеет некоторые ограничения а именно низкую ефективность при большой нагрузки на CPU. Хотя и Node хорошо справляется конкурентной обработкой множества запросов, он все же лн плоха справляется с таким операциями как генеррование графики, обработка изображений. К счастью, существует обходной путь в котором можно виполнять такие операции по очереди или в отдельном процессе.

**2)Недостаточная или отсуствуящая документация для некоторых модулей в npm **
Философия Node.js предполагает свободу разработчиков в выборе модулей и средств. Это приводит к тому что разрабочтки тратят много времени чтобы определить какая именно билиотека  им нужна для решения поставленной задачи. Порой сложно найти хорошо документированную, протестированую библиотеку без сторонних ефектов для вашего приложения

##Плюсы Python
**1)Простота в использовании**
Python имеет краткий и выразительный синтаксис, который помагает писать програмы котрые будет легко поддержывать и разшырять. Также благодаря тому что Python имиет динамическую типизацию код становиться менее детализирован, но более модульным и разшыряемым. Читабельность Python кода облегчает взаемодействие разрабочиков внутри команды, и позволет им тратить большую часть времення на решение реальных задач, а не просмотр и изученее кодовой бази.
Более того Python довльно прост в изучении, по этому опытному разработчику не составит тркда перейти на Python за разумное время.
**2)Быстрота разработки**
Разработка програм на Python происходит на много бистрее чем на таких языках как Java или С++. Хотя стоит отметить, что нельзя дать точную оценку того в разнице в скорости разработки, большинство експертов соглашаются что разработка Python в 5-10 раз быстрее чем на Java, не говоря про C и C++. Но за быстроту разработке нужно платить, быстродействие Python меньше чем у компилтруемых языков.

**3)Обширная стандартная библиотека и екосиистема**

Большая стандартная библиотека для бек-енд разработки одна из зисльных сторон Python в сравнении с  Node.js. Если вы посмотрите на стандартную библиотеку которая идет всместе з Javascript, то она относительно минимальная. Для более продвинутиых задач нужноо подключать сторнних библиотек. Например Python имеет стандартную фукцию для удаленние папки, создания временных файлов, парсинга аргументов, юнит тестирования и логирования.

##Недостаки Python
**1)Ограниченость приминение Python **

Область применение Python ограниченна серверными и декстпными приложениями, его поддежрка отсутсвует на мобильных платформах и браузерах
**2)Остутсвие поддержки DSL (Domain-specific Languages)**
Javascript позволяет разработчикам использовать DSL и транспайлеры такие как Babel для создания нового синтаксиса, который оптимизирует разработку UI.

## Области примениния

Этом краткий обзор демонстрирует что Node и Python  не идеальны. Но так что тогда использовать? Ответ - обе платформи хорошы для разных типов задач.

Событийно-ориентированая архитектура Node.js, которая позволеет одновременно обрабатывать много запросов, очень хороша для чатов и колаборативных приложений, или  приложений реального времени.
Python в свою очередь отлично подходит для обработки большого количества даных, машинного обучения.

##Заключение
Выбирая между Python и Node.js, вам стоит обратить внимание на скорость разработки, потребность в маштабировании, и тип вашего приложения. Есле ваше преложение требует скорости разработки и большой нагрзки на CPU выбирите  Python. Есливам нужно написать SPA или бекенд для чат приложения выбирайте Node.js.


#Node.js vs Python.Какую платформу выбрать для ващего следующего проект?

Не смотря на то что PHP и Node.js могут справляться с приложениями любой сложности, они созданы на основе разных концепций  и архитектур. Если вы владелец приложения выбирающий между двумя плавтформами, вы должны иметь ввиду их основные преймущества и недостатки.
Node.js и PHP одни из самих часто используемых средств для разрабоки веб-сайтов. PHP - скрипотовый язык созданый Rasmus Lerdorf в 1994, являлся языком номер один ери Web 1.0. Показательное проявление успеха PHP являются системы управлениия контентом, такие как WordPress, Joomla и Drupal, с их помощью работают милионы блогов ы веб порталов. Node.js это предстваитель более новых технологий веб-разработки. В отличии от PHP, Node.js не является языком програмирования, это среда выолнения котороя использует JavaScript  для написание приложений на стороне сервера. Представлен в  2009, Node.js продемострировал силу  JavaScript при разработкие собитийно-ориентированых, data-driven приложений епохи Web 2.0


##Плюсы Node.js

**1) Быстрое серверное решение**
Node.js позволяет используя очередь событий JavaScript создавать приложения с неблокирующим вводом/выводом которые способны обрабативать несколько запрсов одновременно.  Используя встроенною в JavaScript  асинронность, можно создавать высокомасштабируемые серверные приложения, которые максимизируют использование одного СPU и памяти компьютера при одновременной обработке большего количества запросов, чем обычные многопоточные серверы. Такая функциональность делает Node.js прекрасным выбором для приложений реального времени и те которые требут большого количесива операций ввода/ввывода
**2) Один язык на фронт-енде и бек-енде**
Много популярных JS фреймворков таких как React или Vue написаны на JavaScript, который явояется основным языком всех современных браузеров. Используя Node.js на сервере вы получаете все приймущества скрипотовго языка на обееих платформах.
Иметь один язык на фронт-енде и бек-енде очень хорошо для обеспечения подержки вашего приложения і кординации меєду членами вашей команды.
**3) Гибкость**
Node.js не имеет стогих правил или жестких зависемостей, что остоавлеят простор для созидания и креативности при разработке приложений. Разработчки сами выбирают архитектуру, зависмости

##Недостаки Node.js

**1)Малая ефективность в операциях интесивно использущих CPU**

Событийно-ориентированая архитектура Node.js имеет некоторые ограничения а именно низкую ефективность при большой нагрузки на CPU. Хотя и Node хорошо справляется конкурентной обработкой множества запросов, он все же лн плоха справляется с таким операциями как генеррование графики, обработка изображений. К счастью, существует обходной путь в котором можно виполнять такие операции по очереди или в отдельном процессе.

**2)Незрелость платформи**
вместе с стабильными станжартными библиотеками такие как HTTP or Crypto, достпуно множество библиотек от сторонних разработчыков. Эта екососитема еще не достаточно сфомировалась, и к сожаление приходится зависеть от не очень качесвенно протестированых модулейю

##Плюсы PHP
**1) Большая кодовая база**

PHP огормною кодовою базу для всевозможных решений от систем управления контентом до мощных фреймворков таких как Laravel, Symfony. Например с помощью WordPress можно запустить свой блог за считанные минути.

**2) Переносимое решения**

PHP дасточно независим от платформы, он может быть запущен почти на любом сервере и на любой платформе.

В тоже время, имеется шырокий выбор хостингом которые с поддержкой PHP, и вам не нужно орендовать полноценный сервер с SSH доступом что бы запустить ваш проект, в отличии от Node.js. Из етого слежует что инграция PHP проектов и их развертывание несколько проще для небольшых компаниий или для отдельных лиц который могут запускать и управляиь своими приложениями без знаний консольных команд, системы Linux

**3) Спроектирована для WEB**
В отличии от  Java или Python и других языков програмирования общего назначения, PHP был разработан специально для Web. Именно по эотму он содержит всю необходимую функциональномть для работы с HTML, серверами, базами даных. C всеобъемлющим языком PHP, в большинтсве случаев можно обойтись минимальным количесвом JS кода на фронт-енде.


##Недостаки PHP
**1) Плохое разделение ответственности (SoC)**
PHP не очень хорош в реализации патерна MVC, котрый является рекомендованым в веб-разработке. Очень часто можно можно встретить микс HTML и PHP, что выливается в неочень красивый и сложно поддержываемый код, где бизнес логик смешана с представлением
**2) Устаревшая клиент-серверная модель**
PHP  следует класической клиент-серверной модели где запрос страници иницирует приложение, соидиненние с базой даннных, их обработкой и рендерингом HTML. Это делает PHP несклько медленее в сравненнии с Node.js приложениями, которые инициируются при запуске, и по этом Node больше подходит для написания прилоений реального времени. правда сотоит отметит что такой недостаток PHP можно обойти с помощью Memcached, но это создает дополнительную зависимость для вашего приложения.

##Итак, что же выбрать ?
Как вы уже знаете, Node.js и PHP имеют свои сильные стороны и слабые стороны. Но как сделать выбор ?

Концепция и реализация  Node.js отлчино подходит для приложений реаьного врмени и как бекенд SPA приложений. В свою очередь екосистема PHP создала огромное количество решений проверных годами, для разных сфер дейтелности от блогинга до e-commerce. Написание подобного решений с нуля может занять много времене.


Итак, при выборе между Node.js и PHP, вы должны обязательно определить, какой тип приложения вы собираетесь написать, каковы требования хостинга вашего клиента, и какова скорость разработки вам нужна. Если ваш клиент ищет стандартизированное решение с обширной поддержкой хостинга, Вы должны рассмотреть возможность использования PHP. С другой стороны, Node.js-лучший вариант для RTAs (приложений реального времени), таких как чаты и SPA (одностраничные приложения).

Обзор TypeScript 3.0

30.08.2018 Майкрософт представила новую версую TypeScript [https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/]

Если вы еще не знакомы с TypeScript, то стоит обратить на него внимание. TypeScript это надстройка над JavaScript, основай ее цель: привнести статическую типизацию в современный JS. Комплиятор TypeScript сканирует код в котором можна определить или антировать типы, и в случае неправильного использования типа он генерирует ошибки, в чистом JS, ошибка могла проявится только на етапе выполнения.
Также TSC переобразует ваш TypeScript в JS код необохимого вам ECMAScript стандарта, который может выполнятся как в браузере так и на бекендэ(Node.js). TypeScript отлично подходит для больших приложений, так как статический анализ код становится намного проще.

Начать работать с TypeScript очень просто, установите его через npm:
```bash
npm install -g typescript
```


#Список новведений TypeScript 3.0

##Ссылки на проекты (Project references)

Очень распотраненной практикой является иметь несколько етапов сборки вашего проекта. Например ваше приложение может иметь две папки src и test, или вы храните код фрот-енда в папаке client и код бекенда в папке server, а общий код для хранится в папке shared. Такие зависимоти довольно сложно поддерживать и чтобы это решить в TypeScript 3.0 были введены проектные ссылки

Project references позволяют TypeScript  проектам зависить от других TypeScript проектов, такие зависимости нужно определять в tsconfig.json файле, где нужно указать путь к tsconfig.json файлу зависимости. Это позволит разбиттьь вашу монолитнуую кодовую базу на несколько проектов, TypeScript сам определит почердность компиляции и структуру компилированого кода. Это зделает возможным процес инкрементальной компиляции, что приведет к уменьшению времени сборки проекта.

Пример использование проектных ссылок

```json
// ./src/client/tsconfig.json
{
    "compilerOptions": {
        "composite": true,
        "declaration": true,
        "outDir": "../../lib/client",
        "strict": true, "module": "esnext", "moduleResolution": "node",
    },
    "references": [
        { "path": "../server" }
    ]
}
```

Было добавлено два новых параметра composite и references

В references нужно укзывать tsconfig.json или папки которые их соддержат. Каждая ссылка сейчас обьект с одним свойством path, она говорит TSC что компиляация данного проекта требует компиляции указанного пректа.

В свою очередь, свойвто composite  определяет можно ли ссылатся на даный проект другим проектам.

Режим --build

TypeScript 3.0 предостваит набор API для ссылки на проекты, что бы другие средства поддердывали инкрементальное поведение. Например gulp-typescript уже использует ети возможности. Хотя,для большинства маленкиъ проектов нет надобности подключать сторниие утилиты. Именно для етого в tsc  был добавлен флаг --build (алиас -b). Команда tsc -b  собирает принамет несколько проектов и собирает их вмести с зависимостями.
Флаг -b должен задан первым, далее можно указать опциональные параметры:

--verbose: показывает каждый шаг что требуется для сборки
--dry: собирает проект, без генерирования файлов
--clean: делает попытку удалить ранее скомпилируемые файли
--force: делает принудительную не инкрементальную сборку проекта

##Извлечение и распределение списка аргуметов функции с помощью кортежей

JavaScript повзоляет нам воспринимать аргументы функции как обьекты первого класа (first-class values) - благодаря использование ключевого слова arguments  или остаточных параметров (...rest)

```javascript
function call(fn, ...args) {
    return fn(...args);
}
```
Функцию call можно вызвать с любым количеством параметров, в отличии от других языков JavaScript  не требует перегрузки функций, с разным количеством параметров. Но к сожалению, до этого момента не было хорошего способа статически определить несколько возмоных вызовов в TypeScript.
К счастью TypeScript 3.0 позволяет делать rest параметры обобщенными. Вместо определения кажой возможной перегрузки функции, ми говорим что остаточный параметр ...args функции fn должен наследовать клас array.

```typescript
function call<TS extends any[], R>(fn: (...args: TS) => R, ...args: TS): R {
    return fn(...args);
}
```
Когда ми вызовем функцию call, TypeScript попытается извлечь типы аргументов из того что мы передадим функции fn:

```typescript
function foo(x: number, y: string): string {
    return (x + y).toLowerCase();
}

// Парметр `TS` определен как `[number, string]`
call(foo, 100, "Hello owrld");
```

##Расширенный типи кортежей

Теперь кортежи  позволяют указывать необязательные элементы

```typescript
/**
 * 2D или 3D  координаты .
 */
type Coordinate = [number, number, number?];
```
Тип Coordinate создает кортеж который может иметь три или два елемента.

Также кортежи теперь могут иметь остаточные параметры

```typescript
type OneNumberAndSomeStrings = [number, ...string[]];
```

Последним нововведением с кортежами есть возможности задавать пустые кортежы.

```typescript
type EmptyTuple = [];

```

## Новый тип - unknown

Тип any самый мощный тип в TypeScript, так как вместо него можна подстаавить люьой другой тип или значение, он не заставляет нас делать какие-то либо проверки перед вызовом функции или попыке достпупа к свойству.
В большинтсве случаев это полезно, но может вызвать проблемы на етапе выполнения.

```typescript
let bar: any = 10;
bar.x.prop;
bar();
new bar();
```
Бывают случаи когда нужно использовать менее универсальный тип в TypeScript. Это полезно если вам нужно показать то что результат функции может быть значением, и что клиентскому коду нужно сделать кое-какие проверки перед еого использованием
В TypeScript 3.0 был введен новый тип unknown. Перемнной тип unknown можно присвоить любое значение, но переменную типа unknown нельзя присвоить перемной другого типа, без проверки на овсместимость типов. Так нельзя получать и добавлять свойства перемнной типа unknown

```typescript
let bar: unknown = 10;

function hasXYZ(obj: any): obj is { x: any, y: any, z: any } {
    return !!obj &&
        typeof obj === "object" &&
        "x" in obj && "y" in obj && "z" in obj
}

// Перед тем как работать с свойствами нужно проверить их наличе
if (hasXYZ(bar)) {
    // ... теперь мы получили достпу к свойствам
    bar.x.prop;
    bar.y.prop;
    bar.z.prop;
}

```

##Поддержка defaultProps в JSX

Если вы когда нибудь использовали параметры по умолчанию в TypeScript/JavaScript, вы наврное знаете насколько это удобно при вызове функций. В React существует похожая концепция для свойств компонента. Во время создание нового елмента компонента, React проверяет свойство defaultProps, что-бы передать его в props, если они не были указаны.  

```typescript jsx
import * as React from "react";
import * as ReactDOM from "react-dom";

export class Greet extends React.Component {
    render() {
        const { name } = this.props;
        return <div>Hello ${name.toUpperCase()}!</div>;
    }

    static defaultProps = {
        name: "world",
    };
}
const res = ReactDOM.renderToString(<Greet />);
```

Обратите внимание на то что, в <Greet />, не нужно задавать свойство name. Когда елемент Greet будет создаваться его значение возвоться из defaultProps. К сожалению TypeScript не понимает , что defaultProps имеет какое-либо отношение к вызовам JSX. Вместо этого, нужно определять свойства как необязательны и делать про проаерку на существование свойства в функции render.

```typescript jsx
export interface Props { name?: string }
export class Greet extends React.Component<Props> {
    render() {
        let { name } = this.props;
        if(!name){
          name='Default';
        }
        return <div>Hello ${name.toUpperCase()}!</div>;
    }
    static defaultProps = { name: "world"}
}
```
В TypeScript 3.0 был добавлен новый пвесдоним типа для пространства имен JSX - LibraryManagedAttributes, не смторя на длинное имя, это всего лишь спомагатильный тип который говорит TypeScript какие атрибути JSX тег принимает  

```typescript jsx
export interface Props {
    name: string
}

export class Greet extends React.Component<Props> {
    render() {
        const { name } = this.props;
        return <div>Hello ${name.toUpperCase()}!</div>;
    }
    static defaultProps = { name: "world"}
} 
let el = <Greet />
```

##Директива /// <reference lib="..." /> 

Многие разработчки сталкивались с проблемой что полифили(библиотеки которые добавляют новые API в старые браузеры), часто имеют свои собственные файли для определения типов(.d.ts файлы) который пытаются сами определить типы для API котрые они реализуют. В некотрых члучаях это хорошо, но ети определения глобальны и могут конфликтовать с встореным файлом lib.d.ts. Например декларации типов для core-js могут конфликтовать с встореным файлом lib.es2015.d.ts.
 
 Чтобы решит эту проблему в TypeScript 3.0 был добавлен новй способ для определения типов встореных API
 
```typescript jsx
/// <reference lib="es2015.promise" />
export {};
 ```
 
 
# Использование Axios в React

Почти любому веб-проекту нужно работать с REST API. Axios это легковесный HTTP клиент который базируется на $http сервисе Angular.js и очень похож на Fetch API.
Axios базируется на Promise и поэтому можно воспользоваться преимуществами  async и await для написания читаемого асинхронного кода. Также библиотека позволяет перехватывать и и отменять запросы, кроме этого она имеет встроенную защиту от межсайтовых подделок запросов. Но главным преимуществом библиотеки является удобное для использования API!

Использовать Axios внутри React.js приложения очень просто. В этой статье приводится пример работы с сторонним REST API в React веб-приложении. Начнем с того что добавим Axios в проект:

[code language="bash"]
# установка с помощью yarn
$ yarn add axios
# установка с помощью npm
$ npm install axios --save
[/code]

## GET запросы

Для начала создадим компонент PersonList и в методе жизненного цикла componentDidMount сделаем GET с помощью axios.

[code language="bash"]
import * as React from 'react';
import * as axios  from 'axios';

export class PersonList extends React.Component {
  state = {
    people: []
  }
  componentDidMount() {
    axios.get(`https://jsonplaceholder.typicode.com/users`)
      .then(res => {
        const people = res.data;
        this.setState({ people });
      })
  }
  render() {
    return (
      <ul>
        { this.state.persons.map(person => <li key={person.id}>{person.name}</li>)}
      </ul>
    )
  }
}
[/code]
В коде выше используется метод axios.get(url) который возвращает promise, который в результате в вернёт объект response. Необходимые нам данные хранятся в поле data.
Если необходимо можно получить некоторые метаданные о запросе, например статус код (res.status) или более детально в объекте res.request.

## POST запросы
Кроме GET запросов библиотека axios умеет работать и с другими HTTP методами, такими как POST или PUT. Давайте создадим форму которая позволяет отправить введенные пользователем данные на сервер.

[code language="javascript"]
import * as React from 'react';
import * as axios  from 'axios';

export class PersonList extends React.Component {
   constructor() {
      super(this);
      this.state={id:""};
  }
  handleChange = event => {
    this.setState({ userName: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();
    const requestData = { user:{
      userName: this.state.userName
    }};
    axios.post(`https://jsonplaceholder.typicode.com/users`, request)
      .then(result => {
        console.info(result);
        console.info(result.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            User Name:
            <input type="text" name="User name" onChange={this.handleChange} />
          </label>
          <button type="submit">Add person</button>
        </form>
      </div>
    )
  }
}
[/code]

При POST запросе объект  респонса такое же как в GET запросе.

## DELETE  запрос

Мы можем удалять сущности через API используя метод axios.delete, передавая туда URL как параметр. Давайте поменяем нашу форму, так чтобы она удаляла а не добавляла юзера.

[code language="javascript"]
import * as React from 'react';
import * as axios  from 'axios';

export  class PersonList extends React.Component {
  constructor() {
    super(this);
    this.state={id:""};
  }
  handleChange = event => {
    this.setState({ id: event.target.value });
  }

  handleSubmit = (event =>{
    event.preventDefault();
    axios.delete(`https://jsonplaceholder.typicode.com/users/${this.state.id}`).then(result => {
        console.info(result,result.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person ID:
            <input type="text" name="id" onChange={this.handleChange} />
          </label>
          <button type="submit">Delete user</button>
        </form>
      </div>
    )
  }
}
[/code]

## Глобальная конфигурация 

axios позволяет задать параметры которые будут подставляется в все запросы автоматически. Например можно задать базовой URL API или токен авторизации

[code language="javascript"]
axios.defaults.baseURL = 'https://api.domain.com';
axios.defaults.headers.common['Authorization'] = 'JWT_TOKEN_HERE';
axios.defaults.headers.post['Content-Type'] = 'application/json';
[/code]

Также можно создать несколько инстансов конфигурации

[code language="javascript"]
// Передаем параметры по умолчанию при создании инстанса
const instance = axios.create({
  baseURL: 'https://api.domain.com'
});

// Alter defaults after instance has been created
instance.defaults.headers.common['Authorization'] = 'JWT_TOKEN_HERE';
[/code]


# kotlin vs java : на чем писать под Android

Если ты разработчик приложений на Android, то наврнека как основной язык програмирования ты используешь Java. Но известно ли тебе что появились новые языки програмирования, которые могут посревноватся с Java за лидерством в даном сегменте.
Одим из таких языков является  Kotlin, относительно молодой язык и по мнению некотрых експертов он станет заменой Java в мобильной разработке.
В етой статье содержыится детальный анализ и сравнения Java и Kotlin, котрый поможет вам решить на каком языке програмирования написать ваш следующий проект.

## Java
Большинство разработчкив предпочытают Java при написании  Android  приложении, в основном и-за того что много лет Java был рекомендуемым Google языком а также тем что сам Android был написан на Java. Для тех кто не знаком с Java напомним что это строго типизированный объектно-ориентированный язык программирования, разработанный компанией Sun Microsystems. Он явлется втроым по пулярности языком програмирования на GitHub.

## Преймущества Java
- прост в изучении и понимании 
- кросплатформеность
- Android базируется на Java - Android SDK содержит много стандартних Java билиотек
- Java имеет огоромную open-source екосистему
- Ускоренная сборка с помощью Gradle 
- Java приложения несколько компактнее в сравнении с написаными на Kotlin 

## Недостатки Java
- ограничения Java создают проблеми с архитектурой Android API
- являясь очень подробным языком (verbose language), Java требует написания большого колиства кода, что делает появление багов более вероятным
- Java медленне в сравнение с компилируемими языками, а также использует много памяти

##Kotlin
Kotlin - статически типизированный язык программирования, работающий поверх JVM и разрабатываемый компанией JetBrains. Основная цель разрабоки - добавить современных функции и фич в Java. Также Kotlin можна компилировать в JavaScript или в Native для запска на  iOS платформе. Все, что требуется, - это установить плагин Kotlin и позволить ему настроить ваш проект.

## Преймущества Kotlin
- бурно развивается как язык под Android разработку, кроме того используется на бек-енде, например в Spring 5
- легкий переход с Java на Kotlin - просто установити плагин Kotlin, добавте его в Gradle  билд  файлы и нажмите кнопку 'Convert'
- наличие extension functions которые помагают разрабатывать чистые API
- наличие null в системе типов, проблема с null значениями очень распотрена в Java
- Kotlin лаконичний язык, что уменьшает количество потенциальных ошибок
- совместимый с Java - можно разрабативать модули на Kotlin  и бить увереным что они будут работать вмести с существуюющим Java кодом, также Kotlin совместим со всеми Java библиотеками и фреймвоками

## Недостатки Kotlin

- Довольно крутая кривая обучения при переключении целых команд на Kotlin из-за лаконичного синтаксиса языка 
- меньшая скорость компиляции в сравнении с Java 
- значительно меньшее комюнити разработчиков, по этому может быть сложно быстро получить ответ на вопрос на Stackoverflow 
- авто-комплит Android Studio и компиляция проекта работает несколько медление в сравнении с чисто  Java  проектами

Заключение 
Хотя Kotlin предлагает много преимуществ, которые Java не может, все равно существуют некоторые недостатки. Но Kotlin имеет огромний потенциал как средтсво разрабоки под Android, так на конференции Google I/O 2017 команда Android объявила об официальной поддержке языка Kotlin для разработки Android-приложений.
